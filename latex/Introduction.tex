\section{Introduction}\label{sec:introduction}

In this paper we take a look at \emph{Automatic Differentiation} through the eyes of \emph{Operational Calculus}. This work is to be viewed as an educational tool for those already familiar with automatic differentiation, who want to familiarize themselves with operational calculus. We first note the difference between the two concepts: automatic differentiation is a name of a collection of techniques for efficient computation of derivatives of differentiable programs, while operational calculus are technique that enable reasoning about analytic properties of differentiable programs by algebraic means. As rates of change (derivatives) are analytic properties, and automatic differentiation is used to compute them, we can explain automatic differentiation through the language of operational calculus. This is meant as an educational tool for those already familiar with automatic differentiation, who seek to familiarize themselves with tensor and operational calculus.

To that effect we provide a simple implementation of the memory space $\VV$ and its expansion to $\VV\otimes T(\VV^*)$, where $T(\VV^*)$ is the tensor algebra of its dual, serving by itself as an algebra of programs \cite[Definition~4.1]{OperationalCalculus}.
We provide a construction of operators
\begin{equation}
\DD^n=\{\D^k;\quad 0\le k\le n\}
\end{equation}
that allow us to mimic the generalized shift operator \cite[Theorem~5.2]{OperationalCalculus}
 \begin{equation}
                  	e^{h\D}:\dP\times \VV\to \VV\otimes \T(\VV^*),
         \end{equation}
and projecting it onto the unit $n$-cube, deriving the operator 
\begin{equation}\label{eq:sumd}
\sumd_n:\dP_k\to\dP_{n+k}
\end{equation} 
that increases the order of a differentiable programming space \cite[Proposition~5.1]{OperationalCalculus}.
Source code can be found on GitHub \cite{dCpp}.

